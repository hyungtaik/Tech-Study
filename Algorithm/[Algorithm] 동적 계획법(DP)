# 동적 계획법 (Dynamic Programming, DP)

## 1. 동적 계획법이란?

- 큰 문제를 작은 문제로 나눠서 푸는 알고리즘이다

- 동적계획법 (DP) 알고리즘은 **최적값을 구할 때 주로 사용**한다.

- 동적 계획법은 **큰 문제를 작은 문제로 나눠서 푸는 기법**

- 분할 정복과 같은 방식이지만 **분할 정복**은 동적 계획법과 달리 계산한 부분 문제를 한번만 쓰고 더이상 쓰지 않기 때문에 **메모이제이션이 필요하지 않다.**

  - 동적 계획법에서는 쪼개진 작은 문제가 중복되지만, **분할 정복은 절대로 중복될 수 없다.**

  

  ### 1) 동적 계획법의 조건

  - 두 가지 속성을 만족해야 동적 계획법으로 문제를 풀 수 있다.

    - **Overlapping Subproblem** : 겹치는 부분(작은) 문제
    - **Optimal Substructure** : 최적 부분구조

    

  - #### (1) Overlapping Subproblem

    - **겹치는 부분 문제(overlapping subproblem)** 는 어떤 문제가 여러개의 부분문제(subproblem)으로 쪼개질 수 있을때 사용하는 용어이다. 이때 '부분 문제'란, 항상 새로운 부분 문제를 생성해내기 보다는 계속해서 같은 부분 문제가 여러번 재사용되거나 재귀 알고리즘을 통해 해결되는 문제를 가리킨다.

      >Ex)
      >
      >• 문제: N번째 피보나치 수를 구하는 문제
      >• 작은 문제: **N-1번째 피보나치 수를 구하는 문제, N-2번째 피보나치 수를 구하는 문제**
      >
      >• 문제: N-1번째 피보나치 수를 구하는 문제
      >• 작은 문제: **N-2번째 피보나치 수를 구하는 문제, N-3번째 피보나치 수를 구하는 문제**
      >
      >• 문제: N-2번째 피보나치 수를 구하는 문제
      >• 작은 문제: **N-3번째 피보나치 수를 구하는 문제, N-4번째 피보나치 수를 구하는 문제**

      

  - #### (2) Optimal Substructure

    - **최적 부분구조(optimal substructure)**는 어떤 문제의 최적의 해결책이 그 부분 문제의 최적의 해결책으로 부터 설계될 수 있는 경우를 말한다. 즉, 최적 부분구조 일때 **문제의 정답을 작은 문제의 정답에서 부터 구할 수 있다.** 이 속성은 동적 계획법이나 그리디 알고리즘의 유용성을 판별하는데 사용되기도 한다.

      > Ex)
      >
      > • Optimal Substructure를 만족한다면, 문제의 크기에 상관없이 어떤 한 문제의 정답은
      > 일정하다.
      > • 10번째 피보나치 수를 구하면서 구한 **4번째 피보나치 수**
      > • 9번째 피보나치 수를 구하면서 구한 **4번째 피보나치 수**
      > • …
      > • 5번째 피보나치 수를 구하면서 구한 **4번째 피보나치 수**
      > • 4번째 피보나치 수를 구하면서 구한 **4번째 피보나치 수**
      > • 4번째 피보나치 수는 항상 같다. -> **겹치는 부분문제**의 **정답이 항상 같다!**

    - **이처럼 같은 값을 매번 구하는 것은 매우 비효율적이다.** 이때 이를 해결할 수 있는 방법이 바로 **메모이제이션(Memoization)**이다.

  

  ### 2) 메모이제이션 (Memoization)

  - 동적 계획법에서 각 문제는 **한 번만** 풀어야 한다. 중복되는 부분 문제를 여러번 풀지 않는다는 뜻이다.

    - Optimal Substructure를 만족하기 때문에 같은 문제는 구할 때마다 정답이 같다. 
    - 정답을 한 번 구했으면 그 정답을 캐시에 메모해놓는다.

  -  중복된 계산을 막기 위해 저장된 결과를 배열에 저장한 뒤, 다음에 계산이 필요할 때 저장된 값을 불러와 중복을없애 호출을 줄일 수 있다.

  - 시간 복잡도가 줄어든다.

    - **모든 문제를 한 번씩만 푼다.**
    - O(N)

    

  ### 3) Top - Down

  - **재귀**와 같은 방식으로 위에서 아래로 내려오는 방식

  - 함수 호출을 줄이기 위해, **메모이제이션을 사용**한다.

  - ```java
    // 일반 재귀
    int fib(int n){
    	if(n == 1 || n == 2) return 1;
    	return fib(n-1) + fib(n-2);
    }
    
    // 메모이제이션을 적용한 Top-Down 방식의 DP
    Arrays.fill(memo,-1);
    int fib(int n){
        if(n == 1 || n == 2) return 1;
        if(memo[n] > 0) return memo[n];
        
        memo[n] = fib(n-1) + fib(n-2);
        return memo[n];
    }
    ```

    

  ### 4) Bottom - Up

  - Top - Down 방식과 달리, **반복문을 이용해서 처음 값부터 다음 값을 계산해나가는 방식**

  - ```java
    int fib(int n){
    	memo[0] = 0;
    	memo[1] = 1;
    	for(int i = 2; i <= n; i++){
    		memo[i] = memo[i-1] + memo[i-2];
    	}
    	return memo[n];
    }
    ```

  

  ### 5) 알고리즘 동작 방식

  - Top - Down
    - 1. 구하고자 하는 큰 문제를 작은 부분 문제로 나눈다.
    - 2. 가장 작은 부분 문제(종료 조건)부터 푼 뒤 값을 저장한다. -> 메모이제이션
    - 3. 메모이제이션된 부분 문제들의 해를 이용하여 차례로 더 큰 상위 문제의 답을 구한다.
    - 4. 3 과정을 가장 큰문제(구하고자 하는 큰 문제)에 도달할 때까지 반복한다.

  - Bottom - Up

    - 1. 문제를 크기가 작은 문제부터 차례대로 푼다.

    - 2. 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다.

    - 3. 작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다.

    - 4. 반복하다 보면 가장 큰 문제를 풀 수 있다.

      

  ### 6) 동적 계획법의 초기화

  - 이미 계산한 것들을 다시 계산하지 않기 위해서 계산한 것과 계산하지 않은 것의 차이가 있어야 한다.

  - 계산하지 않은 값은 초기값 그대로이고, 계산한 값은 바뀌어있기 때문에 이를 통해 구분한다.

  - 계산되지 않을 값으로 초기화 해준다.

    - 계산된 값이 최소 0일수 있는 경우 보통 -1을 사용

    

  ### 7) Top-Down VS Bottom-Up

  - Top-Down 방식에 메모이제이션을 했다는 가정하에 시간복잡도는 같다.
  - 실제 걸리는 시간은 일반적으로 Top-Down DP가 더 길다고 알려져 있다.
  - 재귀 DP의 장점은 **점화식 그대로 호출되기 때문에 형식/순서에 얽매이지 않는다.** 또한 소스의 가독성도 좋다.
  - For문 DP의 장점은 **시간이 조금은 적게 걸린다는 것이다.** 
  - 문제에 따라서 적절히 잘 선택하여 사용해야 한다.



### 📎 결론

>1. DP는 큰 문제를 작은 문제들로 분할하여 그것을 이용해 큰 문제를 해결하는 방법이다.
>2. 분할정복과 다른 점은 DP의 경우 작은 부분 문제의 답이 항상 같아야 한다는 것이다.



