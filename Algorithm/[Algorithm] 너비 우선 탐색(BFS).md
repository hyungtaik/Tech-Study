# 너비 우선 탐색 (Breadth First Search , BFS)

## 📎 그래프 탐색이란?

- **그래프(Graph)** : 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료 구조. 
  - 정점(vertex,node), 간선(edge,link) 로 그래프를 표현
- 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것
  - Ex) 특정 노드에서 다른 노드로 갈 수 있는지 없는지, 특정 노드가 서로 연결되어 있는지



### 1. 너비 우선 탐색이란?

- **루트 노드 (혹은 다른 임의의 노드) 에서 시작해서 인접한 노드를 먼저 탐색하는 방법**

  - 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.

  - 방문한 정점들을 체크하여 이전에 방문한 정점을 또 방문하지 않도록 효율적으로 한다. 

    - ex) 방문한 정점들을 체크하는 bool 배열

  - 즉, 깊게(Deep) 탐색하기 전에 **넓게(Wide)** 탐색하는 것이다.

  - **두 노드 사이의 최단 경로** or **임의의 경로를 찾고 싶을 때** 사용한다.

    - ```markdown
      Example) 인터넷 상의 연결된 모든 컴퓨터를 그래프로 표현한 후 내 컴퓨터와 친구의 노트북 사이에 존재하는 경로를 찾는 경우
      
      - 깊이 우선 탐색의 경우 : 모든 컴퓨터 관계를 다 살펴봐야 할 지도 모른다(최악의 경우)
      - 너비 우선 탐색의 경우 : 내 컴퓨터로부터 가까운 관계부터 탐색
      ```

  - BFS가 DFS보다 좀 더 복잡하다.



### 2. BFS의 특징

- 직관적이지 않은 면이 있다.
- BFS는 시작 노드에서 시작해서 거리에 따라 단계별로 탐색한다고 볼 수 있다.
  - 멀리 떨어진 노드는 나중에 탐색하는 방식이기 때문에 **최단 경로를 탐색할 때 활용하기 좋은 방식**이다.
- BFS는 재귀적으로 동작하지 않는다.
- 그래프 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다는 것이다.
  - 이를 검사하지 않을 경우 무한 루프에 빠질 위험이 있다.
- BFS는 방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료 구조인 **큐(Queue)**를 사용한다.
  - 큐에 저장된 순서대로 탐색
    - 선입선출(FIFO)의 방식을 활용해야 하기 때문에 큐를 활용
  - 일반적으로 큐를 이용해서 반복적 형태로 구현하는 것이 잘 동작한다.
  - Prim, Dijkstra 알고리즘과 유사하다.



### 3. BFS의 과정

- 1. 루트 노드에서 시작
  2. 루트 노드와 인접하고, 방문된 적이 없는 노드를 큐에 삽입
  3. 큐에서 dequeue하여 가장 먼저 큐에 저장한 노드를 방문

  >![image](https://user-images.githubusercontent.com/39832802/91533164-620b9780-e94a-11ea-8f60-65bc099340af.png)
  >
  >( 사진 출처: [heejeong Kwon님의 기술블로그](https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html) )
  >
  >
  >
  >1) 시작 노드를 방문한다. (방문한 노드 체크)
  >
  >- 큐에 방문된 노드를 삽입(enqueue)한다.
  >- 초기 상태의 큐에는 시작 노드만이 저장
  >  - 시작 노드의 이웃 노드를 모두 방문한 다음, 이웃의 이웃들을 방문한다.
  >
  >2) 큐에서 꺼낸 노드와 인접한 노드들을 모두 차례로 방문한다.
  >
  >- 큐에서 꺼낸 노드를 방문한다.
  >- 큐에서 커낸 노드과 인접한 노드들을 모두 방문한다.
  >  - 인접한 노드가 없다면 큐의 앞에서 노드를 꺼낸다.(dequeue)
  >  - 인접한 노드가 있다면 인접 노드를 삽입(enqueue)한다.
  >  - 방문 체크를 한다.
  >
  >3) 큐가 소진될 때까지 계속한다.



### 4. BFS 구현

- 자료 구조 **큐(Queue)를 이용**

- BFS 의사코드(pseudo code)

  ```pseudocode
  void search(Node root) {
    Queue queue = new Queue();
    root.marked = true; // (방문한 노드 체크)
    queue.enqueue(root); // 1-1. 큐의 끝에 추가
  
    // 3. 큐가 소진될 때까지 계속한다.
    while (!queue.isEmpty()) {
      Node r = queue.dequeue(); // 큐의 앞에서 노드 추출
      visit(r); // 2-1. 큐에서 추출한 노드 방문
      // 2-2. 큐에서 꺼낸 노드와 인접한 노드들을 모두 차례로 방문한다.
      foreach (Node n in r.adjacent) {
        if (n.marked == false) { // 방문하지 않은 경우
          n.marked = true; // (방문한 노드 체크)
          queue.enqueue(n); // 2-3. 큐의 끝에 추가
        }
      }
    }
  }
  ```



### 5. BFS의 구현방식, 시간 복잡도

- **인접 행렬 VS 인접 리스트**

  - 인접 행렬 : 이차원 배열
    - O(N^2)
    - N개의 노드에 대해서 N개의 다른 노드와 연결이 되어있고, 방문되지 않은 노드를 체크해야하므로 **O(N^2)**
  - 인접 리스트 : 링크드리스트 배열, 어레이리스트 배열, 어레이리스트를 저장하는 어레이 리스트 등과 같이 구현 가능
    - O(N+E)
    - 자료구조 vector 혹은 연결 리스트로 표현된 경우 N개의 노드에 대해서 연결된 E개의 간선만큼 탐색을 진행하므로 **O(N+E)**

  > ![image](https://user-images.githubusercontent.com/39832802/91535061-8c128900-e94d-11ea-800b-41a4dbbe1c40.png)
  >
  > ( 사진 출처: [sukong님의 기술블로그]([https://velog.io/@sukong/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%9C%EB%85%90-%EB%84%88%EB%B9%84%EC%9A%B0%EC%84%A0%ED%83%90%EC%83%89BFS-lp8zywtn](https://velog.io/@sukong/알고리즘-개념-너비우선탐색BFS-lp8zywtn)) )

- DFS와 마찬가지로 그래프 내에 **적은 숫자의 간선만을 가지는 희소 그래프(Sparse Graph)의 경우** 인접행렬보다 **인접 리스트를 사용하는 것이 유리!**



### 📎 결론

>1. BFS는 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법
>   - 너비 우선 탐색을 위해 방문한 정점들을 차례로 저장한 후 꺼낼 수 있는 자료구조 **큐**가 필요
>   - 방문한 정점들을 체크가 필요
>2. 최단 거리를 탐색할 경우 BFS 알고리즘 활용이 유용하다.
>3. 적은 수의 간선을 가진 경우, 인접행렬 방식이 아닌 인접 리스트 방식의 구현이 효율적이다. 
>   - 인접 리스트의 시간 복잡도가 O(N+E)
>   - 인접 행렬의 시간 복잡도는 O(N^2) 



